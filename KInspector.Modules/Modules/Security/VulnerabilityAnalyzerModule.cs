using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using Kentico.KInspector.Core;

namespace Kentico.KInspector.Modules
{
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>
    /// When adding support for new Kentico version, .txt file with default instance files must be added
    /// and the version recognition has to be slightly improved to work with minor versions.
    /// </remarks>
    public class VulnerabilityAnalyzerModule : IModule
    {
        #region "Constants"

        private static readonly Regex textboxRegex = new Regex("(txt[a-zA-Z0-9]*\\.Text)");
        private static readonly Regex hiddenRegex = new Regex("(hdn[a-zA-Z0-9]*\\.Text)");
        private static readonly Regex labelRegex = new Regex("(lbl[a-zA-Z0-9]*\\.Text)");
        private static readonly Regex XssFalsePositiveRegEx = new Regex(".Text = \\\"[a-zA-Z\\s\\.]*\\\"");
        private static readonly Regex queryRegex = new Regex("QueryHelper\\.GetString");
        private static readonly Regex requestRegex = new Regex("Request\\.QueryString");
        private static readonly Regex cookieRegex = new Regex("CookieHelper\\.GetValue");
        private static readonly Regex getQueryRegex = new Regex("URLHelper\\.GetQueryValue");

        private static readonly Regex executeDataSetRegex = new Regex("ExecuteDataSet");
        private static readonly Regex executeQueryRegex = new Regex("ExecuteQuery");

        /// <summary>
        /// Array of regular expressions used for vulnerability detection.
        /// </summary>
        private static readonly Regex[] patterns = { textboxRegex, hiddenRegex, labelRegex, queryRegex, requestRegex, cookieRegex, getQueryRegex };


        /// <summary>
        /// Array of regular expressions used for highlighting.
        /// </summary>
        private static readonly Regex[] highlightPatterns = { textboxRegex, hiddenRegex, labelRegex, queryRegex, requestRegex, cookieRegex, getQueryRegex, executeDataSetRegex, executeQueryRegex };


        /// <summary>
        /// Regular expression for matching <c>Text</c> property assignments.
        /// </summary>
        private static readonly Regex textPropertySetRegex = new Regex("\\.Text\\s*=");


        private static readonly Regex HrefAttributeRegex = new Regex(".*href=\"?.*");
        private static readonly Regex AltAttributeRegex = new Regex(".*alt=\"?.*");
        private static readonly Regex TitleAttributeRegex = new Regex(".*title=\"?.*");


        /// <summary>
        /// Array of regular expressions used for HTML attributes detection.
        /// </summary>
        private static readonly Regex[] HtmlAttributePatterns = { HrefAttributeRegex, AltAttributeRegex, TitleAttributeRegex };

        #endregion


        #region "IModule interface methods"

        public ModuleMetadata GetModuleMetadata()
        {
            return new ModuleMetadata
            {
                Name = "Vulnerability analyzer",
                Comment = "Prints files which were added by the customer and their vulnerabilities.",
                SupportedVersions = new[] { 
                    new Version("7.0"),
                    new Version("8.0"), 
                    new Version("8.1"), 
                    new Version("8.2")
                },
                Category = "Security",
            };
        }

        public ModuleResults GetResults(IInstanceInfo instanceInfo)
        {
            List<string> report = new List<string>();

            bool isWebSite = ProjectCodeFilesHelper.Current.IsWebSiteProject(instanceInfo.Directory);

            List<string> customerCodeFiles = ProjectCodeFilesHelper.Current.GetCustomerProjectCodeFiles(instanceInfo.Directory, instanceInfo.Version, isWebSite, true).ToList();
            if (customerCodeFiles.Count == 0)
            {
                return new ModuleResults
                {
                    ResultComment = "No customer files found.",
                    Status = Status.Good
                };
            }

            report.AddRange(customerCodeFiles);

            VulnerabilityAnalysisResults results = new VulnerabilityAnalysisResults();
            AnalyzeVulnerabilities(instanceInfo.Directory, customerCodeFiles, ref results);
            string resultString = PrintResults(results);
            if (!string.IsNullOrEmpty(resultString))
            {
                report.Add(string.Empty);
                report.AddRange(resultString.Split(new[] { "<br />" }, StringSplitOptions.None));
            }

            return new ModuleResults
            {
                Result = report,
                Trusted = true
            };
        }

        #endregion


        #region "Methods"

        /// <summary>
        /// Analyses code files for presence of security vulnerabilities.
        /// </summary>
        /// <param name="pathToKenticoInstance">Path to Kentico instance (e.g. <c>C:\inetpub\wwwroot\myKenticoInstance\CMS</c>).</param>
        /// <param name="filesWithinInstance">Files to be analysed within the instance (relative paths).</param>
        /// <param name="results">Analysis results (the results are appended).</param>
        private void AnalyzeVulnerabilities(DirectoryInfo pathToKenticoInstance, IEnumerable<string> filesWithinInstance, ref VulnerabilityAnalysisResults results)
        {
            foreach (var fileWithinInstance in filesWithinInstance)
            {
                AnalyzeVulnerabilities(pathToKenticoInstance, fileWithinInstance, ref results);
            }
        }


        /// <summary>
        /// Analyses code file for presence of security vulnerabilities.
        /// </summary>
        /// <param name="pathToKenticoInstance">Path to Kentico instance (e.g. <c>C:\inetpub\wwwroot\myKenticoInstance\CMS</c>).</param>
        /// <param name="fileWithinInstance">File to be analysed within the instance (relative paths).</param>
        /// <param name="results">Analysis results (the results are appended).</param>
        private void AnalyzeVulnerabilities(DirectoryInfo pathToKenticoInstance, string fileWithinInstance, ref VulnerabilityAnalysisResults results)
        {
            var filePath = Path.Combine(pathToKenticoInstance.FullName, fileWithinInstance);
            var lines = File.ReadAllLines(filePath);
            int lineNo = 1;
            foreach (var line in lines)
            {
                string sqlInjection = null;
                string potentialSqlInjection = null;
                string potentialXss = null;

                AnalyzeSqlInjection(line, ref sqlInjection, ref potentialSqlInjection);
                AnalyzeXss(line, ref potentialXss);

                if (!string.IsNullOrEmpty(sqlInjection))
                {
                    results.SqlInjections.Add($"File: '{fileWithinInstance}', line {lineNo}: {HttpUtility.HtmlEncode(sqlInjection)}");
                }
                if (!string.IsNullOrEmpty(potentialSqlInjection))
                {
                    results.PotentialSqlInjections.Add($"File: '{fileWithinInstance}', line {lineNo}: {HttpUtility.HtmlEncode(potentialSqlInjection)}");
                }
                if (!string.IsNullOrEmpty(potentialXss))
                {
                    results.PotentialXss.Add($"File: '{fileWithinInstance}', line {lineNo}: {HttpUtility.HtmlEncode(potentialXss)}");
                }

                ++lineNo;
            }
        }


        /// <summary>
        /// Analyses string for presence of SQL injection or potential SQL injection.
        /// </summary>
        /// <param name="line">String to be analyzed.</param>
        /// <param name="sqlInjectionResult">Result of SQL injection analysis (not modified if none found).</param>
        /// <param name="potentialSqlInjectionResult">Result of potential SQL injection analysis (not modified if none found).</param>
        private void AnalyzeSqlInjection(string line, ref string sqlInjectionResult, ref string potentialSqlInjectionResult)
        {
            bool sqlInjectionFound = false;
            bool potentialSqlInjectionFound = false;

            if (ContainsSqlSyntax(line))
            {
                // Check if line contains pattern(s) we are looking for
                sqlInjectionFound = patterns.Any(p => p.IsMatch(line));
            }

            // Check if line contains execute dataset command
            if (line.Contains("ExecuteDataSet(") && line.Contains("+"))
            {
                potentialSqlInjectionFound = true;
            }

            // Check if line contains execute query command
            if (line.Contains("ExecuteQuery(") && line.Contains("+"))
            {
                potentialSqlInjectionFound = true;
            }

            if (sqlInjectionFound)
            {
                sqlInjectionResult = line.Trim();
            }
            if (potentialSqlInjectionFound)
            {
                potentialSqlInjectionResult = line.Trim();
            }
        }


        /// <summary>
        /// Analyses string for presence of XSS vulnerability.
        /// </summary>
        /// <param name="line">String to be analyzed.</param>
        /// <param name="xssResult">Result of XSS vulnerability analysis (not modified if none found).</param>
        private void AnalyzeXss(string line, ref string xssResult)
        {
            bool labelFound = false;
            bool potentialXssFound = false;

            // Check if line contains label text
            if (line.Contains("lbl") && textPropertySetRegex.IsMatch(line) && !XssFalsePositiveRegEx.IsMatch(line))
            {
                labelFound = true;
            }

            if (labelFound)
            {
                potentialXssFound = patterns.Any(p => p.IsMatch(line));
            }

            // Check if line contains HTML attributes
            if (HtmlAttributePatterns.Any(p => p.IsMatch(line)))
            {
                potentialXssFound = true;
            }

            // Check if line contains script registration
            if (line.Contains("ScriptHelper.GetScript"))
            {
                potentialXssFound = true;
            }

            if (potentialXssFound)
            {
                xssResult = line.Trim();
            }
        }


        /// <summary>
        /// Tells you whether <paramref name="str"/> contains SQL syntax
        /// by performing a simple analysis.
        /// </summary>
        /// <param name="str">String to be analyzed.</param>
        /// <returns>True if syntax is found, false otherwise.</returns>
        private bool ContainsSqlSyntax(string str)
        {
            return str.Contains(" OR ") || str.Contains(" AND ") || str.Contains(" IS NULL") || str.Contains("SELECT ");
        }


        /// <summary>
        /// Prints analysis result to string with HTML formatting. Vulnerabilities are highlighted.
        /// </summary>
        /// <param name="results">Results to be printed.</param>
        /// <returns>String with formatted results.</returns>
        private string PrintResults(VulnerabilityAnalysisResults results)
        {
            StringBuilder res = new StringBuilder();

            if (results.SqlInjections.Count > 0)
            {
                res.Append("<strong>Check the following files for SQL injection:</strong><br />")
                        .Append(PrintHighlightedResults(results.SqlInjections)).Append("<br />");
            }
            if (results.PotentialSqlInjections.Count > 0)
            {
                res.Append("<strong>Check the following files for potential SQL injection:</strong><br />")
                        .Append(PrintHighlightedResults(results.PotentialSqlInjections)).Append("<br />");
            }
            if (results.PotentialXss.Count > 0)
            {
                res.Append("<strong>Check the following files for XSS:</strong><br />")
                        .Append(PrintHighlightedResults(results.PotentialXss)).Append("<br />");
            }

            return res.ToString();
        }


        /// <summary>
        /// Prints results, vulnerabilities are highlighted using HTML formatting.
        /// </summary>
        /// <param name="results">Results to be printed.</param>
        /// <returns>String with formatted highlighted results.</returns>
        private string PrintHighlightedResults(IEnumerable<string> results)
        {
            StringBuilder sb = new StringBuilder();
            foreach (string result in results)
            {
                string highlightedResult = HighlightPatterns(result);
                sb.Append(highlightedResult).Append("<br />");
            }

            return sb.ToString();
        }


        /// <summary>
        /// Highlights vulnerability patters in <paramref name="result"/>.
        /// </summary>
        /// <param name="result">Result containing code to be highlighted.</param>
        /// <returns>Result with highlighted vulnerabilities.</returns>
        private string HighlightPatterns(string result)
        {
            foreach (var pattern in highlightPatterns)
            {
                foreach (Match match in pattern.Matches(result))
                {
                    result = result.Replace(match.Value, $"<span style=\"color: red;\">{match.Value}</span>");
                }
            }

            return result;
        }

        #endregion
    }
}
